{"version":3,"sources":["GrowingCircle.js","MainCanvas.jsx","App.js","index.js"],"names":["GrowingCircle","color","x","y","radius","maxRadius","growRate","this","needsRender","context","beginPath","strokeStyle","arc","Math","PI","stroke","getForegroundColor","hue","drawBackground","fillStyle","getBackgroundColor","fillRect","canvas","width","height","drawCircles","circles","render","getMousePos","evt","rect","getBoundingClientRect","clientX","left","clientY","top","MainCanvas","props","canvasRef","useRef","useState","setCircles","mousePos","renderStuff","useCallback","current","getContext","useEffect","tick","filter","circle","console","log","interval","setInterval","clearInterval","newCircle","addEventListener","newMousePos","ref","window","innerWidth","innerHeight","App","className","id","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e70ce1aa.chunk.js","sourcesContent":["class GrowingCircle {\n  /**\n   * Creates a growing circle that can be drawn on a canvas\n   * @param {String} color the color to draw the circle (css color string)\n   * @param {Number} x center of circle\n   * @param {Number} y center of circle\n   * @param {Number} radius initial starting radius of circle\n   * @param {Number} maxRadius how large the circle should get before it marked for destruction\n   * @param {Number} growRate coefficent that grows the circle\n   */\n  constructor(color, x, y, radius, maxRadius, growRate = 1.02) {\n    this.color = color;\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n    this.maxRadius = maxRadius;\n    this.growRate = growRate;\n  }\n  /**\n   * Perform one 'tick' of growing pattern, set render flag.\n   * @return true if radius is still less than maxRadius\n   */\n  tick() {\n    this.radius *= this.growRate;\n    // console.log(`radius now ${this.radius}`)\n    this.needsRender = true;\n    if (this.radius < this.maxRadius) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Draw the circle in its current state. Clears render flag.\n   * @param {CanvasRenderingContext2D} context the context to draw with\n   */\n  render(context) {\n    this.needsRender = false;\n    context.beginPath();\n    context.strokeStyle = this.color;\n    context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\n    context.stroke();\n  }\n}\n\nexport default GrowingCircle;","import React, { useRef, useEffect, useState, useCallback } from 'react'\nimport GrowingCircle from './GrowingCircle';\n\nconst MainCanvas = ({ ...props }) => {\n\n  const canvasRef = useRef(null);\n\n  const [circles, setCircles] = useState([]);\n  const hue = useRef(null);\n  const mousePos = useRef(null);\n\n  /**\n   * draw all the things\n   */\n  const renderStuff = useCallback(() => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    drawBackground(context, hue.current);\n    drawCircles(context, circles);\n  }, [circles]);\n\n  useEffect(() => {\n    renderStuff();\n  }, [renderStuff]);\n\n  /**\n   * update state of all the things\n   */\n  const tick = useCallback(() => {\n    hue.current = (hue.current + 1) % 360;\n    setCircles(circles => circles.filter(circle => circle.tick()));\n  }, [])\n\n  // run main tick loop\n  useEffect(() => {\n    console.log('setting interval')\n    const interval = setInterval(() => {\n      tick();\n    }, 50);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [tick]);\n\n  // spawn a new GrowingCircle every period\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (mousePos.current) {\n        console.log(`spawning circle at ${mousePos.current.x}, ${mousePos.current.y}`);\n        const newCircle = new GrowingCircle(\n          getForegroundColor(hue.current),\n          mousePos.current.x,\n          mousePos.current.y,\n          5,\n          1000\n        );\n        setCircles(circles => [...circles, newCircle]);\n      }\n    }, 100);\n    return () => {\n      clearInterval(interval);\n    };\n  }, [])\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    //report the mouse position on click\n    canvas.addEventListener(\"mousemove\", (evt) => {\n      const newMousePos = getMousePos(canvas, evt);\n      mousePos.current = newMousePos;\n    }, false);\n    canvas.addEventListener(\"mouseout\", (evt) => {\n      mousePos.current = null;\n    }, false);\n  }, [])\n\n  return <canvas ref={canvasRef} width={window.innerWidth} height={window.innerHeight} {...props} />\n}\n\nconst getBackgroundColor = (hue) => {\n  return `hsl(${hue}, 80%, 50%)`;\n}\n\nconst getForegroundColor = (hue) => {\n  return `hsl(${(hue + 180) % 360}, 80%, 50%)`;\n}\n\nconst drawBackground = (context, hue) => {\n  context.fillStyle = getBackgroundColor(hue);\n  context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n}\n\n/**\n * draw all the circles.\n * @param {CanvasRenderingContext2D} context \n * @param {Array<GrowingCircle>} circles\n */\nconst drawCircles = (context, circles) => {\n  for (const circle of circles) {\n    // if (circle.needsRender()) {\n    circle.render(context);\n    // }\n  }\n}\n\n/**\n * Get mouse position relative to a canvas event\n * @param {*} canvas \n * @param {*} evt \n * @returns \n */\nconst getMousePos = (canvas, evt) => {\n  const rect = canvas.getBoundingClientRect();\n  return {\n    x: evt.clientX - rect.left,\n    y: evt.clientY - rect.top\n  };\n}\n\nexport default MainCanvas","import './App.css';\nimport MainCanvas from './MainCanvas';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MainCanvas id=\"backgroundCanvas\" />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}